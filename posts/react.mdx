---
title: React
tags:
  - react
  - 前端框架
---

React 是一个用于构建用户界面的 JavaScript 库，最初由 Facebook 开发和维护。它主要用于开发单页面应用程序 (SPA)，通过构建可复用的组件来创建动态和响应迅速的用户界面。React 的核心理念是声明式编程和组件化，这使得开发和维护复杂的应用程序变得更加容易。

## React 简介

### React 的特点

**组件化**：React 采用组件化开发的方式，将用户界面分解成一个个独立的组件，这些组件可以重复使用和组合，提升了代码的可维护性和可复用性。

**声明式**：React 使用声明式编程来描述用户界面状态，这使得代码更加直观和易于理解。开发者只需要描述应用在某个状态下应该是什么样子，而不需要手动操作 DOM 来更新界面。

**虚拟 DOM**：React 通过使用虚拟 DOM 来提升性能。虚拟 DOM 是 React 在内存中构建的一棵轻量级 DOM 树，当状态发生变化时，React 通过比较虚拟 DOM 和真实 DOM 的差异（diffing），仅更新需要改变的部分，从而提高了性能。

**单向数据流**：React 中的数据流是单向的，即数据只能从父组件传递到子组件，这使得数据管理变得更加简单和可预测。

**高效**：由于虚拟 DOM 和高效的 diff 算法，React 可以在保持性能的同时频繁更新 UI。

### 虚拟 DOM

虚拟 DOM 是 React 的一大亮点，它是 React 在内存中维护的一棵轻量级 DOM 树。当组件的状态发生变化时，React 会先在虚拟 DOM 中更新视图，然后再计算出最小的变更部分，最后只更新真实 DOM 中需要变化的部分。

**虚拟 DOM 的工作流程如下：**

1. 当组件状态或属性改变时，React 重新渲染虚拟 DOM。
2. React 比较新旧虚拟 DOM 的差异，计算出需要更新的部分。
3. React 将变化的部分更新到真实 DOM 上。

## 安装和环境配置

### 创建 React 项目

Create React App 是官方提供的一个工具，用于快速创建和配置 React 应用程序。

安装 Node.js 和 npm：在创建 React 项目之前，需要确保已经安装了 Node.js 和 npm（Node 包管理器）。可以从 [Node.js 官网](https://nodejs.org/en) 下载并安装最新版本。

```bash
# 安装最新版本
npx create-react-app@latest project_name

# 进入项目
cd project_name

# 运行
npm start
```

### 项目结构介绍

Create React App 创建的项目典型结构如下：

```text
my-app/
├── node_modules/              # 包含项目的所有依赖包
├── public/                    # 静态资源
│   ├── favicon.ico
│   ├── index.html
│   └── ...
├── src/                       # 项目文件
│   ├── App.css
│   ├── App.js
│   ├── index.css              # 全局样式文件
│   ├── index.js               # React 入口文件
│   └── ...
├── .gitignore                 # git忽略文件
├── package.json               # node工具包管理文件
└── README.md                  # 项目的自述文件
```

### 常用开发工具和插件

- **代码编辑器**：[VS Code](https://code.visualstudio.com/) 或 [IDEA](https://www.jetbrains.com/idea/)
- **浏览器开发插件**：[React Developer Tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
- **版本控制工具**：[git](https://git-scm.com/downloads)

## JSX 语法

### 什么是 JSX？

JSX (JavaScript XML) 是一种语法扩展，允许在 JavaScript 代码中编写类似 HTML 的结构。它被 React 用来描述用户界面。尽管看起来像 HTML，JSX 实际上会被 Babel 转译成 JavaScript 函数调用，从而生成 React 元素。

```jsx
const element = <h1>Hello, world!</h1>;
```

JSX 实际上是被 Babel 转译成普通的 JavaScript 代码：

```js
const element = React.createElement('h1', null, 'Hello, world!');
```

### JSX 语法规则

**基本语法**

```jsx
const element = <h1>Hello, world!</h1>;

// 嵌套元素
const element2 = (
  <div>
    <h1>Hello, world!</h1>
    <p>Welcome to learning React!</p>
  </div>
);
```

**属性和事件**

在 React JSX 语法中，属性和事件均采用小驼峰命名法：

```jsx
// 属性
const element = <input type="text" defaultValue="Hello" />;

// 事件
const handleClick = () => console.log('Button clicked!');
const button = <button onClick={handleClick}>Click Me</button>;

// 类名（使用 className 而非 class）
const div = <div className="my-class"></div>;
```

**表达式与 JSX**

在 JSX 中可以使用大括号 `{}` 来嵌入 JavaScript 表达式：

```jsx
// 变量
const name = 'John';
const element = <h1>Hello, {name}!</h1>;

// 函数调用
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}
const element2 = <h1>Hello, {formatName(user)}!</h1>;

// 三元运算符
const isLoggedIn = true;
const element3 = <div>{isLoggedIn ? 'Welcome back!' : 'Please sign up.'}</div>;
```

**只能返回一个根元素**

如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来：

```jsx
// 使用 div 包裹
const element = (
  <div>
    <h1>标题</h1>
    <p>内容</p>
  </div>
);

// 或使用 Fragment（空标签）
const element2 = (
  <>
    <h1>标题</h1>
    <p>内容</p>
  </>
);
```

**标签必须闭合**

JSX 要求标签必须正确闭合。像 `<img>` 这样的自闭合标签必须书写成 `<img />`。

**使用驼峰式命名法**

在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 `strokeWidth` 代替 `stroke-width`，用 `className` 代替 `class`。

**内联样式**

在 JSX 中使用内联样式时，需要传递一个对象：

```jsx
export default function TodoList() {
  return (
    <ul style={{ backgroundColor: 'black', color: 'pink' }}>
      <li>打篮球</li>
      <li>看书</li>
    </ul>
  );
}
```

### JSX 与 HTML 的区别

| 特性 | JSX | HTML |
|------|-----|------|
| 属性命名 | 驼峰命名法（`className`、`onClick`） | 小写（`class`、`onclick`） |
| 自闭合标签 | 必须显式关闭（`<img />`） | 可省略斜杠 |
| JavaScript 表达式 | 使用 `{}` 嵌入 | 只能使用静态值 |
| 注释 | `{/* 注释 */}` | `<!-- 注释 -->` |

## 组件基础

组件是 React 的基本构建块。每个组件可以看作是一个独立的、可复用的 UI 单位。组件分为两类：类组件和函数组件。

### 类组件

```jsx
import React, { Component } from 'react';

class Welcome extends Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

export default Welcome;
```

### 函数组件

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

export default Welcome;
```

自从 React 16.8 引入了 Hooks 之后，函数组件变得更加强大和灵活，能够处理以前只有类组件才能处理的复杂状态逻辑和生命周期方法。

### 定义组件

**第一步：导出组件**

`export default` 前缀是一种 JavaScript 标准语法，它允许你导出一个文件中的主要函数以便从其他文件引入。

**第二步：定义函数**

使用 `function Welcome() { }` 定义名为 Welcome 的 JavaScript 函数。

:::warning
React 组件的名称必须以大写字母开头，否则它们将无法运行！
:::

**第三步：添加标签**

```jsx
return <div>Hello World!</div>;

// 多行需要括号包裹
return (
  <div>
    <h1>Hello World!</h1>
  </div>
);
```

### 嵌套和组合组件

```jsx
function App() {
  return (
    <div>
      <Header />
      <Main />
      <Footer />
    </div>
  );
}

function Header() {
  return <h1>Header</h1>;
}

function Main() {
  return (
    <div>
      <Sidebar />
      <Content />
    </div>
  );
}

function Sidebar() {
  return <div>Sidebar</div>;
}

function Content() {
  return <div>Content</div>;
}

function Footer() {
  return <h1>Footer</h1>;
}
```

:::warning
组件可以渲染其他组件，但是请不要嵌套定义组件：

```jsx
// ❌ 错误示例
function App() {
  // 永远不要在组件中定义组件
  function Header() {
    return <h1>Header</h1>;
  }
  return <Header />;
}
```
:::

### 组件的导入导出

**默认导出与导入**

```jsx
// 导出 - Welcome.jsx
export default function Welcome() {
  return <h1>Welcome</h1>;
}

// 导入
import Welcome from './Welcome';
```

**具名导出与导入**

```jsx
// 导出 - components.jsx
export function Welcome() {
  return <h1>Welcome</h1>;
}

export function Greeting() {
  return <h1>Greeting</h1>;
}

// 导入
import { Welcome, Greeting } from './components';
```

## Props

`props`（属性）是 React 组件的输入参数，用于传递数据和事件处理函数。`props` 是从父组件传递给子组件的，子组件不能修改 `props`，它们是只读的。

### 如何使用 props？

**传递 props**

```jsx
import Profile from './Profile.jsx';

function App() {
  return <Profile name="MoFan" age="18" address="China" />;
}
```

**访问 props**

```jsx
// 方式一：通过 props 对象
function Profile(props) {
  return (
    <h1>
      我是 {props.name}，今年 {props.age}，居住在 {props.address}
    </h1>
  );
}

// 方式二：解构 props（推荐）
function Profile({ name, age, address }) {
  return (
    <h1>
      我是 {name}，今年 {age}，居住在 {address}
    </h1>
  );
}

// 设置默认值
function Profile({ name, age = 20, address }) {
  return <h1>我是 {name}，今年 {age}</h1>;
}
```

**展开传递 props**

```jsx
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
```

### props 验证

可以使用 `prop-types` 库对 `props` 进行类型检查：

```bash
npm install prop-types
```

```jsx
import PropTypes from 'prop-types';

function Greeting(props) {
  return <h1>Hello, {props.name}</h1>;
}

Greeting.propTypes = {
  name: PropTypes.string,
};
```

### 传递子组件（Children）

React 有一个特殊的 `props.children`，用来传递嵌套在组件中的子元素：

```jsx
function Wrapper(props) {
  return <div className="wrapper">{props.children}</div>;
}

function App() {
  return (
    <Wrapper>
      <h1>Hello, world!</h1>
    </Wrapper>
  );
}
```

### 子组件传递数据到父组件

通过父组件向子组件传递函数，子组件调用函数传递参数：

```jsx
// 父组件
import { useState } from 'react';
import SonComponent from './SonComponent.jsx';

function FatherComponent() {
  const [user, setUser] = useState(null);

  function getUser(user) {
    console.log(user);
    setUser(user);
  }

  return (
    <div>
      <h1>父组件: {JSON.stringify(user)}</h1>
      <SonComponent getUser={getUser} />
    </div>
  );
}

// 子组件
function SonComponent(props) {
  function transferDataForFather() {
    props.getUser({
      name: '用户名',
      age: '18',
      address: 'China',
    });
  }

  return (
    <button onClick={transferDataForFather}>
      点击传递数据给父组件
    </button>
  );
}
```

## State（状态）

在 React 中，组件的状态（state）是组件内部的数据源，它是一个能够改变组件外观和行为的对象。状态与 `props` 的不同之处在于，`props` 是由父组件传递的是只读的；而状态是由组件自身管理的，可以通过特定的方法进行更新。

### useState Hook

`useState` Hook 提供了两个功能：
- State 变量用于保存渲染间的数据
- State setter 函数更新变量并触发 React 再次渲染组件

```jsx
import { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);

  function handleAdd() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>计数: {count}</h1>
      <button onClick={handleAdd}>+</button>
    </div>
  );
}
```

:::info
`useState` 返回的数组总是正好有两项，使用数组解构来获取它们。惯例是命名为 `[thing, setThing]`。
:::

### 多个 state 变量

```jsx
const [index, setIndex] = useState(0);
const [showMore, setShowMore] = useState(false);
const [name, setName] = useState('');
```

### State 是隔离且私有的

如果你渲染同一个组件两次，每个副本都会有完全隔离的 `state`，改变其中一个不会影响另一个。

```jsx
function App() {
  return (
    <div>
      <Count />  {/* 独立的 state */}
      <Count />  {/* 独立的 state */}
    </div>
  );
}
```

### 更新 state 中的对象

你不应该直接修改存放在 React state 中的对象。当你想要更新一个对象时，需要创建一个新的对象，然后将 state 更新为此对象：

```jsx
// ❌ 错误：直接修改
const [position, setPosition] = useState({ x: 0, y: 0 });
position.x = 5;

// ✅ 正确：创建新对象
setPosition({
  ...position,
  x: 5,
});

// 或完全替换
setPosition({
  x: e.clientX,
  y: e.clientY,
});
```

### 更新 state 中的数组

同对象一样，你需要将 React state 中的数组视为只读的：

| 操作 | 避免使用（会改变原数组） | 推荐使用（返回新数组） |
|------|------------------------|---------------------|
| 添加元素 | `push`，`unshift` | `concat`，`[...arr]` |
| 删除元素 | `pop`，`shift`，`splice` | `filter`，`slice` |
| 替换元素 | `splice`，`arr[i] = ...` | `map` |
| 排序 | `reverse`，`sort` | 先复制数组 |

```jsx
// 添加元素
setList([...list, newItem]);

// 删除元素
setList(list.filter(item => item.id !== id));

// 替换元素
setList(list.map(item => 
  item.id === id ? { ...item, done: true } : item
));

// 插入元素
const insertAt = 2;
const newList = [
  ...list.slice(0, insertAt),
  newItem,
  ...list.slice(insertAt)
];
setList(newList);
```

### 使用 Immer 简化更新

Immer 是一个帮助处理不可变数据结构的库：

```bash
npm install immer
```

```jsx
import { produce } from 'immer';
import { useState } from 'react';

const [myList, setMyList] = useState(initialList);

function handleToggle(artworkId, nextSeen) {
  const nextState = produce(myList, draft => {
    const artwork = draft.find(a => a.id === artworkId);
    artwork.seen = nextSeen;
  });
  setMyList(nextState);
}
```

## 条件渲染

在 React 中，你可以通过使用 JavaScript 的 `if` 语句、`&&` 和 `?:` 运算符来选择性地渲染 JSX。

### 使用 if 语句

```jsx
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign up.</h1>;
}

// 返回 null 表示不渲染任何内容
function Greeting({ isLoggedIn }) {
  if (!isLoggedIn) {
    return null;
  }
  return <h1>Welcome back!</h1>;
}
```

### 使用逻辑 && 运算符

```jsx
function Welcome({ name, isShowName }) {
  return <h1>欢迎你 {isShowName && name}</h1>;
}
```

### 使用三元运算符

```jsx
function Greeting({ isLoggedIn }) {
  return isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>;
}
```

## 渲染列表

### 使用 map 渲染列表

```jsx
function NumberList({ numbers }) {
  return (
    <ul>
      {numbers.map(number => (
        <li key={number.toString()}>{number}</li>
      ))}
    </ul>
  );
}

function App() {
  const numbers = [1, 2, 3, 4, 5];
  return <NumberList numbers={numbers} />;
}
```

### 使用 filter 筛选

```jsx
function NumberList({ numbers }) {
  const evenNumbers = numbers.filter(number => number % 2 === 0);

  return (
    <ul>
      {evenNumbers.map(number => (
        <li key={number.toString()}>{number}</li>
      ))}
    </ul>
  );
}
```

### Key 的重要性

直接放在 `map()` 方法里的 JSX 元素必须指定 key 值：

```jsx
<li key={item.id}>{item.name}</li>
```

**key 需要满足的条件：**
- key 值在兄弟节点之间必须是唯一的
- key 值不能改变

:::warning
不要使用数组索引作为 key，也不要动态生成 key（如 `key={Math.random()}`），这会导致性能问题和 bug。
:::

## 事件处理

### 事件处理器

```jsx
function Button() {
  function handleClick() {
    console.log('Button clicked!');
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

### 事件对象

React 将事件对象 event 作为参数传递给事件处理器函数：

```jsx
function InputField() {
  function handleChange(event) {
    console.log('Input value:', event.target.value);
  }

  return <input type="text" onChange={handleChange} />;
}

// 传递额外参数
function InputField() {
  function handleChange(event, extraArg) {
    console.log(event.target.value, extraArg);
  }

  return <input onChange={e => handleChange(e, 'extra')} />;
}
```

### 类组件中的 this 绑定

在类组件中，事件处理函数需要绑定 this：

**方式一：构造函数中绑定**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log('this is:', this);
  }

  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}
```

**方式二：使用箭头函数（推荐）**

```jsx
class MyComponent extends React.Component {
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}
```

## React 样式化

### 内联样式

```jsx
const MyComponent = () => {
  return <div style={{ color: 'blue', fontSize: '20px' }}>Hello</div>;
};
```

### CSS 文件

```css
/* App.css */
.my-component {
  color: blue;
  font-size: 20px;
}
```

```jsx
import './App.css';

const App = () => {
  return <div className="my-component">Hello</div>;
};
```

### CSS Module

```css
/* styles.module.css */
.button {
  background-color: blue;
  color: white;
}
```

```jsx
import styles from './styles.module.css';

function ButtonComponent() {
  return <button className={styles.button}>Click me</button>;
}
```

### CSS-in-JS

**Styled Components**

```bash
npm install styled-components
```

```jsx
import styled from 'styled-components';

const StyledH1 = styled.h1`
  color: red;
  font-size: 24px;
`;

function App() {
  return <StyledH1>Hello World</StyledH1>;
}
```

**Emotion**

```bash
npm install @emotion/react @emotion/styled
```

```jsx
import styled from '@emotion/styled';

const StyledH1 = styled.h1`
  color: red;
`;

function App() {
  return <StyledH1>Hello World</StyledH1>;
}
```

### Tailwind CSS

```bash
npm install tailwindcss
npx tailwindcss init
```

```jsx
const App = () => {
  return <div className="text-blue-500 text-xl">Hello, world!</div>;
};
```

## 状态管理

### State 与 Props 的区别

| 特性 | State | Props |
|------|-------|-------|
| 定义 | 组件内部管理的数据 | 从父组件传递的数据 |
| 可变性 | 可变，通过 setState 更新 | 不可变，只读 |
| 作用范围 | 局部，仅在定义组件内有效 | 可传递给任意层级子组件 |
| 访问方式 | `useState` Hook 或 `this.state` | 函数参数或 `this.props` |

### 状态提升

当多个组件需要共享状态时，将状态提升到它们的公共父组件：

```jsx
import { useState } from 'react';

function TemperatureInput({ temperature, onTemperatureChange }) {
  return (
    <input
      value={temperature}
      onChange={e => onTemperatureChange(e.target.value)}
    />
  );
}

function BoilingVerdict({ celsius }) {
  return celsius >= 100 ? <p>水沸腾了</p> : <p>水没有沸腾</p>;
}

function Calculator() {
  const [temperature, setTemperature] = useState('');

  return (
    <div>
      <TemperatureInput
        temperature={temperature}
        onTemperatureChange={setTemperature}
      />
      <BoilingVerdict celsius={parseFloat(temperature)} />
    </div>
  );
}
```

### Context API

Context 提供了一种在组件之间共享数据的方式，而不必通过 props 层层传递。

**创建 Context**

```jsx
// ThemeContext.js
import { createContext } from 'react';

const ThemeContext = createContext('light');

export default ThemeContext;
```

**提供 Context**

```jsx
// App.jsx
import ThemeContext from './ThemeContext';

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

**使用 Context**

```jsx
// 使用 useContext Hook（推荐）
import { useContext } from 'react';
import ThemeContext from './ThemeContext';

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Themed Button</button>;
}

// 使用 Consumer
function ThemedButton() {
  return (
    <ThemeContext.Consumer>
      {theme => <button className={theme}>Themed Button</button>}
    </ThemeContext.Consumer>
  );
}
```

## Hooks

Hooks 是 React 16.8 引入的特性，允许你在函数式组件中使用 React 的状态和生命周期特性。

### Hooks 规则

1. **只在最顶层使用 Hook**：不要在循环、条件或嵌套函数中调用 Hook
2. **只在 React 函数中调用 Hook**：在函数组件或自定义 Hook 中使用
3. **按顺序调用 Hooks**：每次渲染时 Hooks 的调用顺序必须一致
4. **命名规则**：自定义 Hook 必须以 `use` 开头

### useState

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  // 直接设置值
  const increment = () => setCount(count + 1);

  // 使用函数式更新（推荐，确保获取最新值）
  const incrementSafe = () => setCount(prev => prev + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}
```

### useReducer

适用于复杂的状态更新或新状态依赖于旧状态的情况：

```jsx
import { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1 };
    case 'decrement':
      return { ...state, count: state.count - 1 };
    default:
      throw new Error('Unknown action');
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h1>计数: {state.count}</h1>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
```

### useContext

```jsx
import { useContext } from 'react';
import ThemeContext from './ThemeContext';

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Button</button>;
}
```

### useRef

`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数：

```jsx
import { useRef } from 'react';

function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

// 存储不需要触发渲染的值
function Timer() {
  const intervalRef = useRef(null);

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      console.log('tick');
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
  };

  return (
    <div>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

### useEffect

`useEffect` 用于处理副作用，如数据获取、订阅、手动修改 DOM 等：

```jsx
import { useEffect, useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // 每次渲染后执行
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  // 仅在挂载时执行（模拟 componentDidMount）
  useEffect(() => {
    console.log('Component mounted');
  }, []);

  // 依赖项变化时执行（模拟 componentDidUpdate）
  useEffect(() => {
    console.log('Count changed:', count);
  }, [count]);

  // 清理函数（模拟 componentWillUnmount）
  useEffect(() => {
    const subscription = subscribeToSomething();
    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return <button onClick={() => setCount(count + 1)}>Click</button>;
}

// 异步数据获取
useEffect(() => {
  async function fetchData() {
    const result = await fetch('http://api.example.com/data');
    const data = await result.json();
    setData(data);
  }
  fetchData();
}, []);
```

### useCallback

缓存函数，避免不必要的重新创建：

```jsx
import { useCallback, useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [list, setList] = useState([]);

  // 只有当 list 变化时才重新创建函数
  const handleSomething = useCallback(() => {
    console.log('处理 list:', list);
  }, [list]);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <ChildComponent onAction={handleSomething} />
    </div>
  );
}
```

### useMemo

缓存计算结果，避免不必要的重复计算：

```jsx
import { useMemo, useState } from 'react';

function ExpensiveComponent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 只有当 count 变化时才重新计算
  const expensiveValue = useMemo(() => {
    console.log('Computing...');
    let result = 0;
    for (let i = 0; i < 1000000000; i++) {
      result += count;
    }
    return result;
  }, [count]);

  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <p>Expensive Value: {expensiveValue}</p>
    </div>
  );
}
```

### 自定义 Hook

自定义 Hook 是利用内置 Hook 来封装可重用功能的函数：

```jsx
import { useState } from 'react';

// 自定义 Hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}

// 使用自定义 Hook
function Counter() {
  const { count, increment, decrement, reset } = useCounter(0);

  return (
    <div>
      <h1>计数: {count}</h1>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>重置</button>
    </div>
  );
}
```

## 生命周期

### 类组件生命周期

**componentDidMount**：组件挂载后调用

```jsx
class MyComponent extends React.Component {
  componentDidMount() {
    // 获取数据、添加事件监听器等
    this.fetchData();
  }

  render() {
    return <div>Hello</div>;
  }
}
```

**componentDidUpdate**：组件更新后调用

```jsx
class MyComponent extends React.Component {
  componentDidUpdate(prevProps, prevState) {
    if (this.props.id !== prevProps.id) {
      this.fetchData(this.props.id);
    }
  }

  render() {
    return <div>Hello</div>;
  }
}
```

**componentWillUnmount**：组件卸载前调用

```jsx
class MyComponent extends React.Component {
  componentWillUnmount() {
    // 清理定时器、取消订阅等
    clearInterval(this.timer);
  }

  render() {
    return <div>Hello</div>;
  }
}
```

### 函数组件（useEffect）

`useEffect` 可以替代上述所有生命周期方法：

```jsx
import { useEffect } from 'react';

function MyComponent({ id }) {
  // componentDidMount + componentDidUpdate
  useEffect(() => {
    fetchData(id);
  }, [id]);

  // componentDidMount
  useEffect(() => {
    console.log('Mounted');
  }, []);

  // componentWillUnmount
  useEffect(() => {
    const timer = setInterval(() => {}, 1000);
    return () => clearInterval(timer); // 清理函数
  }, []);

  return <div>Hello</div>;
}
```

## 路由

React Router 是 React 应用中最常用的路由库。

### 安装

```bash
npm install react-router-dom@6
```

### 基本配置

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/profile">Profile</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}

function Home() {
  return <h1>Home Page</h1>;
}

function About() {
  return <h1>About Page</h1>;
}

function Profile() {
  return <h1>Profile Page</h1>;
}

function NotFound() {
  return <h1>404 - Page Not Found</h1>;
}
```

### BrowserRouter vs HashRouter

- **BrowserRouter**：使用 HTML5 history API，URL 干净（如 `/about`），需要服务器配置
- **HashRouter**：使用 URL 哈希（如 `/#/about`），不需要服务器配置

### NavLink

`NavLink` 是 `Link` 的升级版，可以为当前激活的链接添加样式：

```jsx
import { NavLink } from 'react-router-dom';

<NavLink 
  to="/home" 
  className={({ isActive }) => isActive ? 'active' : ''}
>
  Home
</NavLink>
```

### 嵌套路由

```jsx
import { Routes, Route, Link, Outlet } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        <Route path="about" element={<About />} />
        <Route path="dashboard" element={<Dashboard />}>
          <Route index element={<DashboardHome />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Route>
    </Routes>
  );
}

function Layout() {
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/dashboard">Dashboard</Link>
      </nav>
      <Outlet /> {/* 子路由渲染位置 */}
    </div>
  );
}

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="settings">Settings</Link>
      <Outlet />
    </div>
  );
}
```

### 路由参数

**params 参数**

```jsx
// 路由配置
<Route path="/profile/:id" element={<Profile />} />

// 组件中获取
import { useParams } from 'react-router-dom';

function Profile() {
  const { id } = useParams();
  return <h1>Profile ID: {id}</h1>;
}
```

**search 参数**

```jsx
import { useSearchParams } from 'react-router-dom';

function Profile() {
  const [searchParams, setSearchParams] = useSearchParams();
  const name = searchParams.get('name');

  return <h1>Name: {name}</h1>;
}

// URL: /profile?name=John
```

**state 参数**

```jsx
// 传递
<Link to="/profile" state={{ userId: 1, userName: 'John' }}>
  Profile
</Link>

// 接收
import { useLocation } from 'react-router-dom';

function Profile() {
  const location = useLocation();
  const { userId, userName } = location.state || {};

  return <h1>User: {userName}</h1>;
}
```

### 编程式导航

```jsx
import { useNavigate } from 'react-router-dom';

function MyComponent() {
  const navigate = useNavigate();

  const goToProfile = () => {
    navigate('/profile');
  };

  const goToProfileWithState = () => {
    navigate('/profile', { state: { userId: 1 } });
  };

  const goBack = () => {
    navigate(-1);
  };

  const goForward = () => {
    navigate(1);
  };

  const replaceHistory = () => {
    navigate('/profile', { replace: true });
  };

  return (
    <div>
      <button onClick={goToProfile}>Go to Profile</button>
      <button onClick={goBack}>Back</button>
    </div>
  );
}
```

### 路由表

```jsx
import { useRoutes } from 'react-router-dom';

const routes = [
  {
    path: '/',
    element: <Layout />,
    children: [
      { index: true, element: <Home /> },
      { path: 'about', element: <About /> },
      { path: 'profile/:id', element: <Profile /> },
    ],
  },
  { path: '*', element: <NotFound /> },
];

function App() {
  const element = useRoutes(routes);
  return element;
}
```

### 路由拦截（权限控制）

```jsx
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const isAuthenticated = localStorage.getItem('token');

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children;
}

// 使用
<Route
  path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>
```

### 路由懒加载

```jsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## 错误边界

错误边界是用于捕获子组件中发生的错误的组件，可以提供回退 UI 并记录错误。

### 实现错误边界

```jsx
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // 记录错误到日志服务
    console.error('Error:', error);
    console.error('Error Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>出错了</h1>
          <button onClick={() => this.setState({ hasError: false })}>
            重试
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 使用
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

### 错误边界无法捕获的错误

- 事件处理器中的错误
- 异步代码中的错误（如 setTimeout）
- 服务器端渲染中的错误
- 错误边界自身抛出的错误

## Refs

Refs 用于访问 DOM 元素或 React 组件实例。

### 在函数组件中使用 useRef

```jsx
import { useRef } from 'react';

function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus</button>
    </div>
  );
}
```

### 在类组件中使用 createRef

```jsx
import React from 'react';

class TextInput extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }

  focusInput = () => {
    this.inputRef.current.focus();
  };

  render() {
    return (
      <div>
        <input ref={this.inputRef} type="text" />
        <button onClick={this.focusInput}>Focus</button>
      </div>
    );
  }
}
```

### forwardRef

用于将 ref 转发到子组件内部的 DOM 元素：

```jsx
import React, { forwardRef, useRef } from 'react';

const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </div>
  );
}
```

### useImperativeHandle

自定义暴露给父组件的实例值：

```jsx
import React, { forwardRef, useRef, useImperativeHandle } from 'react';

const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef(null);

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    clear: () => { inputRef.current.value = ''; },
  }));

  return <input ref={inputRef} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
      <button onClick={() => inputRef.current.clear()}>Clear</button>
    </div>
  );
}
```

## Portal

Portal 允许将子组件渲染到 DOM 中的任意位置，常用于模态框、弹出菜单等。

```jsx
import ReactDOM from 'react-dom';

function Modal({ children, isOpen }) {
  if (!isOpen) return null;

  return ReactDOM.createPortal(
    <div className="modal-overlay">
      <div className="modal-content">
        {children}
      </div>
    </div>,
    document.getElementById('portal-root')
  );
}

// index.html 中需要添加
// <div id="portal-root"></div>

// 使用
function App() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      <Modal isOpen={isOpen}>
        <h2>Modal Title</h2>
        <p>Modal content</p>
        <button onClick={() => setIsOpen(false)}>Close</button>
      </Modal>
    </div>
  );
}
```

:::tip
Portal 渲染的组件虽然在 DOM 树中位于不同位置，但在 React 组件树中仍然是父组件的子组件，事件会正常冒泡到父组件。
:::

## 保持组件纯粹

保持组件纯粹指确保组件的渲染输出仅由其 props 和 state 决定：

1. **无副作用的渲染**：避免在渲染过程中执行副作用
2. **使用纯函数组件**：优先使用函数组件
3. **不直接修改 props 和 state**：使用 setState 或 useState 更新
4. **使用不可变数据结构**：创建新对象/数组而非修改原有的

```jsx
// ❌ 不纯的组件
function BadComponent({ items }) {
  items.push('new item'); // 直接修改 props
  return <ul>{items.map(item => <li>{item}</li>)}</ul>;
}

// ✅ 纯组件
function GoodComponent({ items }) {
  const newItems = [...items, 'new item'];
  return <ul>{newItems.map(item => <li key={item}>{item}</li>)}</ul>;
}
```

:::info 严格模式
React 提供了严格模式，在开发时会调用每个组件函数两次，帮助找到不纯的组件：

```jsx
<React.StrictMode>
  <App />
</React.StrictMode>
```
:::
