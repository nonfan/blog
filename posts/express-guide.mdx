---
title: Express 完整指南
tags:
  - express
  - nodejs
  - 后端
---

## 入门

### 什么是 Express？

Express 是一个基于 Node.js 的 Web 应用框架，旨在简化开发过程。它提供了一组强大的功能和工具，使得构建 Web 应用和 API 更加高效。Express 是一个轻量级的框架，以其简洁的 API 和高度的可定制性受到开发者的喜爱。

### Express 与 Node.js 的关系

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，主要用于构建高性能的网络应用。而 Express 是构建在 Node.js 之上的一个框架，它简化了使用 Node.js 进行 Web 开发的过程。Node.js 提供了基础的服务器功能，而 Express 则在其上提供了更高层次的抽象和功能，例如路由、请求处理、模板渲染等。

### 安装和基本设置

要开始使用 Express，你需要首先安装 Node.js。接下来，可以使用 npm（Node 包管理器）来安装 Express。

#### 安装 Express

打开终端并运行以下命令来创建一个新的项目目录并初始化一个新的 Node.js 项目：

```bash
mkdir my-express-app
cd my-express-app
npm init -y
```

```bash
# 安装 Express
npm install express
```

#### 创建基本的 Express 应用

在项目目录中创建一个名为 app.js 的文件，并添加以下代码来创建一个基本的 Express 应用：

```js
const express = require('express');
const app = express();
const port = 3000;

// 定义一个简单的路由
app.get('/', (req, res) => {
  res.send('Hello World!');
});

// 启动服务器
app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
```

#### 运行应用

在终端中运行以下命令启动服务器：

```bash
node app.js
```

访问 `http://localhost:3000`，你将看到 "Hello World!" 的输出。

### nodemon 工具

在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动关闭，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。

```bash
# 全局安装工具
npm install nodemon -g
```

```bash
# 启动服务
nodemon app.js
```


## 核心概念

### express()

创建 Express 应用程序。 `express()` 函数是 express 模块导出的顶级函数，它用于创建一个 Express 应用程序实例。

```js
const express = require('express');
const app = express();
```

### 请求和响应

在 Express 中，**请求（Request）**和**响应（Response）** 是处理客户端与服务器交互的基础。客户端通过 HTTP 请求发送数据到服务器，服务器处理请求并发送响应。

#### 请求对象 (request)

`request` (简写 req) 包含客户端请求的所有信息，如请求方法、URL、查询参数、请求体、头信息等。常见的属性包括：

| 属性         | 说明                                                                           |
| ------------ | ------------------------------------------------------------------------------ |
| `req.method` | 请求的 HTTP 方法（如 GET、POST、PUT 等）。                                     |
| `req.url`    | 请求的路径（如 `/users`）。                                                    |
| `req.params` | 获取路径中的参数（如 `/user/:id`，其中 `id` 是路径参数）。                     |
| `req.query`  | 获取查询参数（如 `/search?query=express`，其中 `query` 是查询参数）。          |
| `req.body`   | 请求体的数据（用于 POST 或 PUT 请求，需使用中间件解析，如 `express.json()`）。 |

#### 响应对象 (response)

`response` (简写 res) 对象用于向客户端发送响应。常见的方法包括：

| 方法             | 说明                                        |
| ---------------- | ------------------------------------------- |
| `res.send()`     | 发送响应内容，可以是字符串、HTML、JSON 等。 |
| `res.json()`     | 发送 JSON 格式的响应。                      |
| `res.status()`   | 设置响应的 HTTP 状态码。                    |
| `res.redirect()` | 重定向客户端到另一个 URL。                  |
| `res.sendFile()` | 发送文件作为响应。                          |

```js
// 示例：处理请求和发送响应
const express = require('express');
const app = express();
const port = 3000;

app.get('/user/:id', (req, res) => {
  // 获取路径参数
  const userId = req.params.id;

  // 获取查询参数
  const search = req.query.search;

  // 获取请求体（需使用中间件解析，如 express.json()）
  const userData = req.body;

  // 发送响应
  res.status(200).json({ message: `User ID: ${userId}`, search, userData });
});

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
```

### 路由

路由是 Express 应用程序根据请求的路径和方法来执行特定操作的机制。通过路由，开发者可以定义不同 URL 对应的处理逻辑。

#### 基本路由定义

在 Express 中，路由定义遵循 app.METHOD(PATH, HANDLER) 的形式：

- METHOD 是 HTTP 方法（如 GET、POST、PUT、DELETE 等）。
- PATH 是请求路径。
- HANDLER 是一个函数，处理匹配到的请求。

```js
// 处理 GET 请求的路由
app.get('/', (req, res) => {
  res.send('Hello, Express!');
});

// 处理 POST 请求的路由
app.post('/submit', (req, res) => {
  res.send('Form submitted');
});
```

有一个特殊的路由方法 `app.all()` ，用于在所有HTTP 请求方法的路径上加载中间件函数。例如，无论使用 GET、POST、PUT、DELETE 还是 http 模块中支持的任何其他 HTTP 请求方法，都会对路由"/secret"的请求执行以下处理程序。

```js
app.all('/secret', function (req, res) {
  console.log('Accessing the secret section ...');
});
```

#### 路由路径

路由路径与请求方法结合，定义可发出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。

在路由定义中，字符 `?`、`+`、`*` 和 `()` 是正则表达式的元字符，但在字符串路径中它们会被解释为普通字符。下面是它们在正则表达式中的作用以及它们在字符串路径中的解释方式：

`?`：表示前面的字符或子表达式是可选的（即出现零次或一次）。

```js
app.get('/users?/:userId?', (req, res) => {
  res.send(`User ID: ${req.params.userId || 'none'}`);
});
```

`+`：表示前面的字符或子表达式至少出现一次。

```js
app.get('/users+/123', (req, res) => {
  res.send('Matched /users+/123');
});
```

`*`：表示前面的字符或子表达式出现零次或多次。

```js
app.get('/files/*', (req, res) => {
  res.send(`Requested path: ${req.params[0]}`);
});
```

`()`：用于分组字符或子表达式。

```js
app.get('/items/(a|b)', (req, res) => {
  res.send('Matched /items/a or /items/b');
});
```

**字符串路径中的解释**

`?`、`+`、`*` 和 `()`：在字符串路径中，这些字符被视为字面量字符，而不是正则表达式的特殊符号。例如：

```js
app.get('/files/*', (req, res) => {
  res.send('Matched /files/* literally');
});
```

`-` 和 `.`：这些字符在字符串路径中也是字面量字符，不会被解释为特殊含义：

```js
app.get('/files/123-456', (req, res) => {
  res.send('Matched /files/123-456');
});

app.get('/files/abc.def', (req, res) => {
  res.send('Matched /files/abc.def');
});
```

总结来说，在定义路径时，如果使用正则表达式的特性（如 `?`、`+`、`*` 和 `()`），你可以利用它们的特殊含义来匹配复杂的路径。而在字符串路径中，这些字符会被视为普通字符，不具有正则表达式中的特殊功能。

#### 路由参数

路由参数用于在路径中动态捕获变量，通常使用 `:` 语法定义。通过 `req.params` 获取路由参数。

```js
app.get('/user/:id', (req, res) => {
  const userId = req.params.id;
  res.send(`User ID: ${userId}`);
});
```

访问 `http://localhost:3000/user/123` 时，会返回 User ID: 123。

#### 查询参数

通过 `req.query` 对象，可以获取到URL上的请求参数，默认是空对象

```js
app.get('/user', (req, res) => {
  const userId = req.query.id;
  res.send(`User ID: ${userId}`);
});
```

访问 `http://localhost:3000/user?id=123` 时，会返回 User ID: 123。

#### 路由分组与模块化

为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：

1. 创建路由模块对应的 `.js` 文件
2. 调用 `express.Router()` 函数创建路由对象
3. 向路由对象上挂载具体的路由
4. 使用 `module.exports` 向外共享路由对象
5. 在app.js使用 `app.use()` 函数注册路由模块

```js
// 路由模块文件
const express = require('express');
const router = express.Router();

// 定义用户相关的路由
router.get('/', (req, res) => {
  res.send('用户列表');
});

router.get('/:id', (req, res) => {
  res.send(`用户ID: ${req.params.id}`);
});

// 共享路由对象，暴露成员
module.exports = router;
```

```js
// app.js
const express = require('express');
const userRouter = require('./routes/user.js');
const app = express();
const port = 3000;

app.use(userRouter);

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
```

在主应用中添加前缀, 所有相关的路由都会带上前缀。

```js
// 示例: 为路由模块添加前缀
const userRouter = require('./routes/user.js');
app.use('/api', userRouter);
```

### 中间件

中间件是 Express 的核心功能之一，用于处理请求和响应。在路由处理前或后，执行中间件函数以添加功能。

中间件函数是可以访问请求对象(req)、响应对象(res) 以及应用程序请求-响应周期中的下一个中间件函数的函数。下一个中间件函数通常由名为 next 变量表示。

中间件功能可以执行以下任务：

- **执行任意代码**: 可以在请求处理中执行任何类型的逻辑，例如身份验证、日志记录、数据库查询等。
- **更改请求和响应对象**: 可以修改请求（req）和响应（res）对象的内容，比如添加或删除属性，以便后续的中间件或路由能够使用这些信息。
- **结束请求(Request)-响应周期(Response)**: 如果中间件完成了所有必要的操作，可以通过发送响应来结束请求(响应周期)，而无需调用后续的中间件或路由。
- **调用堆栈中的下一个中间件函数**: 如果当前中间件不结束请求-响应周期，应该通过调用 `next()` 函数将控制权交给下一个中间件。

如果当前的中间件函数没有结束请求-响应周期，即没有调用 `res.send()`、`res.json()`、`res.end()` 等方法将数据发回客户端 ，则必须调用 `next()` 将控制权传递给下一个中间件函数。否则，请求将被挂起。

Express 应用程序可以使用以下类型的中间件：

- 应用层中间件
- 路由器级中间件
- 错误处理中间件
- 内置中间件
- 第三方中间件

#### 应用层中间件

使用 `app.use()` 和 `app.METHOD()` 函数将应用程序级中间件绑定到 app 对象的实例，其中METHOD是中间件函数处理的请求的 HTTP 方法（例如 GET、PUT 或POST) 小写。

没有配置请求路径的中间件函数。每次应用程序收到请求时都会执行该函数。

```js
const express = require('express');
const app = express();

app.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});
```

配置请求 `/user/:id` 路径上的中间件函数。该函数针对 `/user/:id` 路径上的任何类型的 HTTP 请求执行。

```js
app.use('/user/:id', function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});
```

一个路由及其处理函数（中间件系统）。该函数处理对 `/user/:id` 路径的 GET 请求。

```js
app.get('/user/:id', function (req, res, next) {
  res.send('USER');
});
```

下面是一个在挂载点加载一系列中间件函数的示例，并带有挂载路径。它说明了一个**中间件子堆栈**，该子堆栈将任何类型的 HTTP 请求的请求信息打印到 `/user/:id` 路径。

> 在 Express 中，中间件子堆栈（middleware sub-stacks）指的是在处理请求时，应用程序可以创建多个中间件层，这些层可以按顺序进行处理。在每个中间件层中，可以使用不同的中间件函数来处理请求和响应对象。

```js
app.use(
  '/user/:id',
  function (req, res, next) {
    console.log('Request URL:', req.originalUrl);
    next();
  },
  function (req, res, next) {
    console.log('Request Type:', req.method);
    next();
  },
);
```

路由处理程序使您能够为路径定义多个路由。下面的示例定义了到 `/user/:id` 路径的 GET 请求的两条路由。第二条路由不会导致任何问题，但它永远不会被调用,因为第一条路由结束了请求-响应周期。

```js
app.get(
  '/user/:id',
  function (req, res, next) {
    console.log('ID:', req.params.id);
    next();
  },
  function (req, res, next) {
    res.send('User Info');
  },
);

// handler for the /user/:id path, which prints the user ID
app.get('/user/:id', function (req, res, next) {
  res.send(req.params.id);
});
```

要跳过路由器中间件堆栈中的其余中间件函数，请调用 `next('route')` 将控制权传递给下一个路由。注意： `next('route')` 仅适用于使用 `app.METHOD()` 或`router.METHOD()` 函数加载的中间件函数。

```js
// 示例: 中间件子堆栈
app.get(
  '/user/:id',
  function (req, res, next) {
    // if the user ID is 0, skip to the next route
    if (req.params.id === '0') next('route');
    // otherwise pass the control to the next middleware function in this stack
    else next();
  },
  function (req, res, next) {
    // send a regular response
    res.send('regular');
  },
);

// handler for the /user/:id path, which sends a special response
app.get('/user/:id', function (req, res, next) {
  res.send('special');
});
```

中间件也可以在数组中声明以实现可重用。

```js
// 示例: 数组中间件堆栈
function logOriginalUrl(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}

function logMethod(req, res, next) {
  console.log('Request Type:', req.method);
  next();
}

const logStuff = [logOriginalUrl, logMethod];
app.get('/user/:id', logStuff, function (req, res, next) {
  res.send('User Info');
});
```

#### 路由级别中间价

路由器级中间件的工作方式与应用程序级中间件相同，只不过它绑定到 `express.Router()` 的实例。

```js
const router = express.Router();
```

使用 `router.use()` 和 `router.METHOD()` 函数加载路由器级中间件。

```js
const express = require('express');
const app = express();
const router = express.Router();

router.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

router.get(
  '/user/:id',
  function (req, res, next) {
    // if the user ID is 0, skip to the next router
    if (req.params.id === '0') next('route');
    // otherwise pass control to the next middleware function in this stack
    else next();
  },
  function (req, res, next) {
    // render a regular page
    res.render('regular');
  },
);

router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id);
  res.render('special');
});

// 挂载路由
app.use('/', router);
```

#### 错误处理中间件

错误处理是指 Express 如何捕获和处理同步和异步发生的错误。 Express 附带一个默认的错误处理程序，因此您无需编写自己的错误处理程序即可开始使用。

##### 捕获错误

确保 Express 捕获运行路由处理程序和中间件时发生的所有错误非常重要。路由处理程序和中间件内的同步代码中发生的错误不需要额外的工作。如果同步代码抛出错误，Express 将捕获并处理它。例如：

```js
app.get('/', function (req, res) {
  throw new Error('BROKEN'); // Express will catch this on its own.
});
```

对于从路由处理程序和中间件调用的异步函数返回的错误，您必须将它们传递给 `next()` 函数，Express 将在其中捕获并处理它们。例如：

```js
app.get('/', function (req, res, next) {
  fs.readFile('/file-does-not-exist', function (err, data) {
    if (err) {
      next(err); // Pass errors to Express.
    } else {
      res.send(data);
    }
  });
});
```

从 Express 5 开始，返回 Promise 的路由处理程序和中间件在拒绝或抛出错误时将自动调用 `next(value)`。

```js
app.get('/user/:id', async function (req, res, next) {
  const user = await getUserById(req.params.id);
  res.send(user);
});
```

如果您向 `next()` 函数传递任何内容（字符串'route'除外），Express 会将当前请求视为错误，并将跳过任何剩余的非错误处理路由和中间件函数。

如果序列中的回调不提供数据，仅提供错误，您可以按如下方式简化此代码：

```js
app.get('/', [
  function (req, res, next) {
    fs.writeFile('/inaccessible-path', 'data', next);
  },
  function (req, res) {
    res.send('OK');
  },
]);
```

##### 编写错误处理程序

定义错误处理中间件函数的方式与其他中间件函数相同，除了使用四个参数而不是三个，特别是使用签名(err, req, res, next) )：

```js
app.use(function (err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

> **警告**: 错误处理中间件始终采用四个参数。您必须提供四个参数才能将其标识为错误处理中间件函数。即使不需要使用 next 一个对象，也必须指定它以维护签名。否则， next 对象将被解释为常规中间件并且无法处理错误。

最后定义错误处理中间件，在其他 `app.use()` 和路由调用之后；例如：

```js
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(
  bodyParser.urlencoded({
    extended: true,
  }),
);
app.use(bodyParser.json());
app.use(methodOverride());
app.use(function (err, req, res, next) {
  // logic
});
```

出于组织（和更高级别的框架）目的，您可以定义多个错误处理中间件函数，就像使用常规中间件函数一样。例如，为使用XHR和不使用 XHR 发出的请求定义错误处理程序：

```js
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(
  bodyParser.urlencoded({
    extended: true,
  }),
);
app.use(bodyParser.json());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
```

```js
// clientErrorHandler
function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' });
  } else {
    next(err);
  }
}
```

```js
// errorHandler
function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
}
```

#### 内置中间件

Express 内置了以下中间件功能：

- `express.static` 提供静态资源，例如 HTML 文件、图像等。
- `express.json` 使用 JSON 有效负载解析传入请求。
- `express.urlencoded` 使用 URL 编码的有效负载解析传入请求。

在服务器，可以使用 `req.body` 来接收客户端发送过来的请求体数据。默认情况下，如果没有配置解析表单数据的中间件，则 `req.body` 为 `undefined`。

可以通过内置中间件 `express.json` 来解析 application/json 格式数据。

```js
app.use(express.json());

app.post('/add', (req, res) => {
  res.send(req.body);
});
```

可以通过内置中间件 `express.urlencoded` 来解析 application/x-www-form-urlencoded 格式数据。

```js
app.use(express.urlencoded({ extended: false }));

app.post('/add', (req, res) => {
  res.send(req.body);
});
```

#### 第三方中间件

非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。

在 `express@4.16.0` 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：

```bash
npm install body-parser
```

```js
const bodyParser = require('body-parser');

app.use(bodyParser.json()); // 解析 JSON 表单格式数据
app.use(bodyParser.urlencoded({ extended: false })); // 解析url-encoded 表单格式数据
```

#### 自定义中间件

除了内置和第三方中间件，开发者还可以根据需求编写自定义中间件。自定义中间件可以做权限验证、请求日志记录、数据预处理等。

编写一个简单的 Express 中间件的步骤如下：

- 中间件函数有三个参数：req（请求对象）、res（响应对象）和 next（传递控制权给下一个中间件函数）。
- 在函数内部，通常会对请求做一些处理，然后调用 `next()` 来让下一个中间件继续处理请求。

```js
// 记录请求的时间
function requestTime(req, res, next) {
  req.requestTime = Date.now();
  next();
}

app.use(requestTime);

app.get('/', (req, res) => {
  res.send(`请求时间：${req.requestTime}`);
});
```

```js
// 权限验证中间件
function auth(req, res, next) {
  const token = req.headers['authorization'];
  if (token === 'secret-token') {
    next(); // 验证通过，继续执行
  } else {
    res.status(403).send('权限不足');
  }
}

app.use('/protected', auth); // 只保护 /protected 路径

app.get('/protected', (req, res) => {
  res.send('访问受保护资源');
});
```

### 静态文件服务

Express 可以通过 express.static 中间件提供静态文件服务，如 HTML、CSS、JS 和图片等文件。静态文件通常存放在 public 文件夹中，并通过特定路径对外公开。

使用 express.static 提供静态文件。

```js
const express = require('express');
const path = require('path');
const app = express();

// 提供 public 目录下的静态文件
app.use(express.static(path.join(__dirname, 'public')));

app.listen(3000, () => {
  console.log('Server is running at http://localhost:3000');
});
```

在这个例子中，客户端可以通过 `http://localhost:3000/index.html` 访问 public 文件夹中的 index.html 文件。

#### 虚拟路径前缀

你可以为静态文件服务设置虚拟路径前缀。例如，将所有静态文件都挂载到 /static 路径下。

```js
app.use('/static', express.static(path.join(__dirname, 'public')));
```

这样，`http://localhost:3000/static/index.html` 将会提供 public 目录中的 index.html 文件。

### 覆盖 Express API

覆盖 Express API 通常指的是对 Express 提供的核心功能（如请求处理、响应发送等）进行自定义修改或扩展。你可以通过编写自定义中间件、修改请求或响应对象，来达到覆盖或增强 Express 的 API 行为。

**常见的覆盖方式：**

- 覆盖 req 和 res 对象的属性或方法：你可以通过中间件向 req（请求）或 res（响应）对象添加自定义方法或属性。
- 全局中间件：可以用来修改 API 的处理方式，比如添加统一的响应格式、捕获错误等。

#### 覆盖 res.send 方法

你可以自定义 `res.send` 方法，使所有响应内容都按照某种统一的格式返回。

```js
const express = require('express');
const app = express();

// 覆盖 res.send 方法
app.use((req, res, next) => {
  const originalSend = res.send; // 保留原始的 send 方法
  res.send = function (body) {
    // 修改 send 方法，将响应数据封装成统一格式
    body = {
      success: true,
      data: body,
    };
    originalSend.call(this, body); // 调用原始的 send 方法
  };
  next(); // 继续传递控制权
});

app.get('/', (req, res) => {
  res.send('Hello World'); // 响应将变为 { success: true, data: "Hello World" }
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

#### 扩展 req 对象

你也可以通过添加自定义属性或方法，扩展 req 对象。例如，在所有请求中添加用户的 IP 地址信息：

```js
app.use((req, res, next) => {
  req.clientIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  next();
});

app.get('/', (req, res) => {
  res.send(`Client IP: ${req.clientIp}`);
});
```

#### 特性

Express API 中的属性是：

- 分配的属性（例如：`req.baseUrl` 、 `req.originalUrl` ）
- 定义为 getter（例如：`req.secure`、`req.ip` ）

由于分配的属性是在当前请求-响应周期的上下文中动态分配给 `request` 和 `response` 对象的，因此无法覆盖它们的行为。

可以使用 Express API 扩展 API 覆盖getter属性。

```js
// 示例: 重写了如何导出req.ip的值
Object.defineProperty(app.request, 'ip', {
  configurable: true,
  enumerable: true,
  get: function () {
    return this.get('Client-IP');
  },
});
```

### 跨域资源共享（CORS）

#### 理解 CORS

##### 什么是 CORS

跨域资源共享（CORS，Cross-Origin Resource Sharing） 是一种机制，它允许受限的资源（如字体、API 等）从不同的域名进行访问。浏览器出于安全原因，通常会阻止网页向不同的域发送请求，这叫做同源策略。同源策略要求：

- 协议（http/https）相同
- 域名相同
- 端口相同

如果前端页面和后端服务器不在同一个域（即跨域），浏览器会拒绝请求，除非服务器明确允许跨域请求，这就需要使用 CORS 机制。

##### CORS 的典型应用场景

- 单页面应用（SPA）使用 API 时，前端和后端的域不同（如前端在 localhost:3000，后端 API 在 localhost:5000）。
- 调用第三方服务的 API。

##### CORS 工作原理

- **简单请求**：如果请求是简单的（例如 GET、POST，不含复杂的自定义 HTTP 头），浏览器会直接发送请求并检查响应中的 CORS 头是否允许该请求。
- **预检请求**（Preflight Request）：如果请求是复杂请求（如使用 PUT、DELETE，或携带自定义头），浏览器会先发送一个 OPTIONS 请求，询问服务器是否允许跨域访问。服务器若允许，会在响应头中返回允许跨域的相关信息。

##### CORS 响应头

1. `Access-Control-Allow-Origin`：指定允许访问资源的源（可以是具体的域名，或 `*` 允许所有域）。

```js
// 允许任意URL访问
response.setHeader('Access-Control-Allow-Origin', '*');
// 只允许 www.example.com 访问
response.setHeader('Access-Control-Allow-Origin', 'http://www.example.com');
```

2. `Access-Control-Allow-Methods`：允许的 HTTP 方法（如 GET, POST, PUT, DELETE）。

默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。

如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。

```js
// 只允许 POST, GET, DELETE, HEAD 请求方法
response.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD');
// 允许所有的 HTTP 请求方法
response.setHeader('Access-Control-Allow-Methods', '*');
```

3. `Access-Control-Allow-Headers`：允许的自定义请求头。

默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：

```
Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、
Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一）
```

如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！

```js
// 运行客户端额外向服务器发送 Content-Type 请求头 和 X-Cutsom-Header 请求头
// 注意： 多个请求头之间用逗号分隔
response.setHeader(
  'Access-Control-Allow-Headers',
  'Content-Type, X-Custom-Header',
);
```

4. `Access-Control-Allow-Credentials`：是否允许客户端发送凭据（如 Cookie）。

```js
response.setHeader('Access-Control-Allow-Credentials', true);
```

#### 使用 cors 中间件解决跨域问题

在 Express 中，可以使用 cors 中间件来方便地处理跨域请求。cors 是一个第三方中间件，允许你在服务器端设置 CORS 头，以便前端跨域访问。

##### 基本使用

```bash
# 安装
npm install cors
```

在 Express 中使用 cors 中间件非常简单，直接调用 `app.use(cors())` 即可。这将允许所有的跨域请求。

```js
const express = require('express');
const cors = require('cors');
const app = express();

// 使用 cors 中间件允许所有跨域请求
app.use(cors());

app.get('/data', (req, res) => {
  res.json({ message: 'This is a CORS-enabled response' });
});

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

##### 限制特定域访问

如果你只想允许某个特定的域访问资源，而不是允许所有跨域请求，可以在 cors 中指定 origin 选项。

```js
app.use(
  cors({
    origin: 'http://example.com', // 只允许来自 example.com 的跨域请求
  }),
);
```

##### 允许多域访问

可以将 origin 选项设置为一个函数，允许来自多个域的请求：

```js
const allowedOrigins = ['http://example.com', 'http://another.com'];

app.use(
  cors({
    origin: function (origin, callback) {
      if (allowedOrigins.indexOf(origin) !== -1 || !origin) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
  }),
);
```

##### 允许携带凭据

如果客户端需要发送凭据（如 Cookie 或认证信息），你需要配置 `Access-Control-Allow-Credentials`，并确保 origin 不能为 `*`，而是一个具体的域名。

```js
app.use(
  cors({
    origin: 'http://example.com',
    credentials: true, // 允许携带凭据
  }),
);
```

##### 设置预检请求的缓存

你可以通过设置 `Access-Control-Max-Age` 响应头来指定预检请求的缓存时间，以减少 OPTIONS 请求的频率。

```js
app.use(
  cors({
    origin: 'http://example.com',
    maxAge: 86400, // 预检请求缓存一天
  }),
);
```

```js
// 示例: 完整的 CORS 解决方案
const express = require('express');
const cors = require('cors');
const app = express();

// 允许来自 http://example.com 的跨域请求，并允许发送凭据
app.use(
  cors({
    origin: 'http://example.com',
    methods: ['GET', 'POST', 'PUT', 'DELETE'], // 允许的请求方法
    allowedHeaders: ['Content-Type', 'Authorization'], // 允许的请求头
    credentials: true, // 允许客户端发送凭据
    maxAge: 600, // 预检请求缓存10分钟
  }),
);

// 一个简单的路由
app.get('/data', (req, res) => {
  res.json({ message: 'CORS is enabled for this route' });
});

app.listen(3000, () => {
  console.log('CORS-enabled web server is running at http://localhost:3000');
});
```


## HTTP 方法与 RESTful API

### HTTP 方法

HTTP 方法是指在 HTTP 协议中用于定义客户端与服务器之间如何交互的请求方式，常见的 HTTP 方法有以下几种：

- GET：用于获取资源，常见用于从服务器请求数据。
- POST：用于提交数据，通常用于创建新的资源。
- PUT：用于更新资源，通常用于替换现有资源。
- PATCH：用于部分更新资源，修改资源的部分数据。
- DELETE：用于删除资源。
- OPTIONS：用于获取服务器支持的 HTTP 方法列表。

```http
GET /users      # 获取用户列表
POST /users     # 创建一个新用户
GET /users/1    # 获取ID为1的用户
PUT /users/1    # 更新ID为1的用户
PATCH /users/1  # 部分更新ID为1的用户
DELETE /users/1 # 删除ID为1的用户
```

### RESTful API

RESTful API 是基于 REST（Representational State Transfer，表现层状态转移）架构风格的 API，采用标准的 HTTP 方法来对资源进行操作。资源通过 URL 表示，并使用 JSON 作为数据格式。

#### RESTful API 设计原则

1. 资源路径：资源通过 URL 定位，URL 应描述资源的含义（使用名词，而非动词）。

例如：`/users` 表示用户资源，`/products` 表示产品资源。

2. HTTP 方法与资源操作对应：

- GET 用于获取资源。
- POST 用于创建资源。
- PUT 或 PATCH 用于更新资源。
- DELETE 用于删除资源。

3. 状态码：使用标准的 HTTP 状态码来表示请求结果。

#### 创建 RESTful API

我们可以结合 HTTP 方法来构建完整的 RESTful API。通常，API 设计会涉及资源的 CRUD（创建、读取、更新、删除）操作。

假设我们要为用户管理创建一个 RESTful API，处理用户的 CRUD 操作。

```js
// RESTful API 示例
const express = require('express');
const app = express();
let users = [{ id: 1, name: 'John Doe' }]; // 模拟的用户数据

app.use(express.json());

// 获取所有用户
app.get('/users', (req, res) => {
  res.json(users);
});

// 获取指定用户
app.get('/users/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ message: 'User not found' });
  res.json(user);
});

// 创建新用户
app.post('/users', (req, res) => {
  const newUser = {
    id: users.length + 1,
    name: req.body.name,
  };
  users.push(newUser);
  res.status(201).json(newUser);
});

// 更新用户
app.put('/users/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ message: 'User not found' });
  user.name = req.body.name;
  res.json(user);
});

// 删除用户
app.delete('/users/:id', (req, res) => {
  users = users.filter(u => u.id !== parseInt(req.params.id));
  res.status(204).send(); // 成功删除，不返回内容
});

app.listen(3000, () => {
  console.log('RESTful API server running on http://localhost:3000');
});
```

这个 API 可以完成以下操作：

- `GET /users`：返回所有用户。
- `GET /users/:id`：返回指定 ID 的用户。
- `POST /users`：创建新用户。
- `PUT /users/:id`：更新指定 ID 用户的信息。
- `DELETE /users/:id`：删除指定用户。

### 状态码与错误处理

在处理 API 请求时，返回合适的 HTTP 状态码能帮助客户端了解操作结果。常见的 HTTP 状态码如下：

- 200 OK：请求成功。
- 201 Created：资源创建成功。
- 204 No Content：请求成功，但没有内容返回（通常用于 DELETE 操作）。
- 400 Bad Request：客户端请求无效。
- 401 Unauthorized：用户未授权。
- 404 Not Found：请求的资源不存在。
- 500 Internal Server Error：服务器内部错误。


## 模板引擎

**模板引擎**使您能够在应用程序中使用静态模板文件。在运行时，模板引擎将模板文件中的变量替换为实际值，并将模板转换为发送给客户端的 HTML 文件。这种方法使得 HTML 页面的设计变得更加容易。

一些与 Express 配合使用的流行模板引擎有Pug 、 Mustache和EJS 。 Express 应用程序生成器使用Pug作为默认值，但它也支持其他几种。

要渲染模板文件，请设置以下应用程序设置属性，在生成器创建的默认应用程序的app.js中设置：

- `views`：模板文件所在的目录，默认为应用程序根目录中的 views 目录。

```js
app.set('views', './views');
```

- `view engine`：要使用的模板引擎。

例如，要使用 Pug 模板引擎：`app.set('view engine', 'pug')`

### Pug

安装对应的模板引擎 npm 包

```bash
npm install pug --save
```

设置视图引擎后，您无需在应用程序中指定引擎或加载模板引擎模块；

```js
app.set('view engine', 'pug');
```

在 views 目录下创建一个名为 index.pug 的Pug模板文件，内容如下：

```pug
html
  head
    title= title
  body
    h1= message
```

然后创建一个路由来渲染 index.pug 文件。如果未设置 view engine 属性，则必须指定 view 文件的扩展名。否则，您可以省略它。

```js
app.get('/', function (req, res) {
  res.render('index', { title: 'Hey', message: 'Hello there!' });
});
```

### 开发模板引擎

使用 `app.engine(ext, callback)` 方法创建您自己的模板引擎。 `ext` 指文件扩展名， `callback` 是模板引擎函数，它接受以下各项作为参数：文件位置、选项对象和回调函数。

```js
// 模板引擎的简单示例
const express = require('express');
const app = express();

var fs = require('fs');
app.engine('mofan', function (filePath, options, callback) {
  fs.readFile(filePath, function (err, content) {
    if (err) return callback(err);
    var rendered = content
      .toString()
      .replace('#title#', '<span>' + options.title + '</span>')
      .replace('#message#', '<h1>' + options.message + '</h1>');
    return callback(null, rendered);
  });
});
app.set('views', './views');
app.set('view engine', 'mofan');
```

在views目录中创建一个名为 index.mofan 的文件，其中包含以下内容。

```
#title#
#message#
```

然后，在您的应用程序中创建以下路由。

```js
app.get('/', function (req, res) {
  res.render('index', { title: 'Hey', message: 'Hello there!' });
});
```


## 数据库集成

添加将数据库连接到 Express 应用程序的功能只需为应用程序中的数据库加载适当的 Node.js 驱动程序即可。

### SQLite

SQLite 是一种轻量级、嵌入式的关系型数据库管理系统。它的设计目标是提供一个零配置、无服务器、跨平台的数据库解决方案。以下是 SQLite 的一些关键特性和限制：

| 特性               | 描述                                                                                                                                                    |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **轻量级**         | SQLite 是一个非常小的数据库系统，整个库的源代码不到 500 KB。无需安装或配置，所有操作都在单个文件中完成。                                                |
| **嵌入式**         | SQLite 是一个嵌入式数据库，直接集成到应用程序中，不需要独立的数据库服务器。操作由应用程序中的 SQLite 引擎直接处理。                                     |
| **零配置**         | 不需要安装、配置或启动数据库服务，所有操作通过直接读写数据库文件完成。适合小型应用和开发过程中。                                                        |
| **事务支持**       | 支持完整的事务功能，包括 ACID（原子性、一致性、隔离性、持久性）事务，支持多种隔离级别来控制事务的并发操作。                                             |
| **跨平台**         | 可以在几乎所有操作系统上运行，包括 Windows、macOS、Linux、iOS、Android 等。数据库文件是跨平台的。                                                       |
| **自包含**         | 数据库引擎的所有功能都包含在一个库文件中，无需外部依赖，数据库文件本身即为整个数据库。                                                                  |
| **只读和只写支持** | 支持只读和只写操作，可以在只读环境中运行，也可以在需要写入的环境中使用，支持并发读操作和适度的并发写操作。                                              |
| **SQL 支持**       | 支持大部分标准 SQL 语法，包括复杂的查询、联接、索引、触发器、视图等，支持 SQL 数据定义语言（DDL）、数据操纵语言（DML）和数据控制语言（DCL）的主要功能。 |

| 限制                        | 描述                                                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **并发写操作限制**          | 虽然 SQLite 支持多个并发读操作，但写操作的并发支持有限。在高并发写操作场景中，SQLite 可能会成为瓶颈。               |
| **不支持存储过程和触发器**  | SQLite 不支持存储过程，但支持触发器。                                                                               |
| **不支持所有 SQL 标准功能** | 尽管 SQLite 支持大部分标准 SQL 功能，但并不完全符合所有 SQL 标准（例如，不支持完全的外键约束和一些高级 SQL 特性）。 |

#### 安装与使用

```bash
npm install sqlite3
```

创建一个 SQLite 数据库文件并进行基本操作的示例代码：

```js
const sqlite3 = require('sqlite3').verbose();

// 创建 SQLite3 数据库连接
const db = new sqlite3.Database('./example.db', err => {
  if (err) {
    console.error('Database connection error:', err.message);
  } else {
    console.log('Database connected');
  }
});

// 创建表
db.run(
  'CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)',
  err => {
    if (err) {
      console.error('Table creation error:', err.message);
    } else {
      console.log('Table created');
    }
  },
);

// 插入数据
db.run(
  'INSERT INTO users (name, email) VALUES (?, ?)',
  ['Alice', 'alice@example.com'],
  function (err) {
    if (err) {
      console.error('Insert error:', err.message);
    } else {
      console.log(`Row inserted with ID ${this.lastID}`);
    }
  },
);

// 查询数据
db.all('SELECT * FROM users', [], (err, rows) => {
  if (err) {
    console.error('Query error:', err.message);
  } else {
    console.log('Rows:', rows);
  }
});

// 关闭数据库连接
db.close(err => {
  if (err) {
    console.error('Close error:', err.message);
  } else {
    console.log('Database connection closed');
  }
});
```

#### Typeorm

> 版本: 0.3.20

在使用 Express.js 搭配 SQLite 时，结合 TypeORM 作为 ORM（对象关系映射）可以极大简化数据库操作。TypeORM 允许你通过 JavaScript 或 TypeScript 来映射 SQLite 数据库表，直接操作对象而不是写原生 SQL 语句，从而提高开发效率。

以下是 Express.js 与 SQLite 数据库结合 TypeORM 的完整示例，涵盖基本的 CRUD 操作。

##### 安装依赖

```bash
npm install typeorm reflect-metadata sqlite3
npm install typescript ts-node @types/node --save-dev
```

- `typeorm`: ORM 工具
- `reflect-metadata`: TypeScript 的元数据反射库（TypeORM 依赖）
- `sqlite3`: SQLite 数据库驱动
- `typescript` 和 `ts-node`: TypeScript 编译工具

##### TypeORM 配置

在项目 src 目录下创建一个 `data-source.ts` 文件，这是 TypeORM 的配置文件。可以指定数据库的类型、路径等。

```ts
// data-source.ts
import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from './entity/User';

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: 'database.sqlite',
  synchronize: true,
  logging: false,
  entities: [User],
  migrations: [],
  subscribers: [],
});
```

`synchronize: true` 会自动同步数据库结构到实体类中，这在开发阶段是非常有用的，但在生产环境中应设置为 false，以避免数据丢失。

如果你将 logging 设置为 true，可以帮助你在开发过程中看到 TypeORM 执行的 SQL 语句，便于调试。

在 `src/entity` 创建实体类:

```ts
// User.ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  email: string;
}
```

在 `src/app.ts` 初始化数据：

```ts
// app.ts
import 'reflect-metadata';
import express, { Request, Response } from 'express';
import { AppDataSource } from './data-source';

const app = express();
app.use(express.json());

AppDataSource.initialize()
  .then(() => {
    // 启动服务器
    app.listen(1234, () => {
      console.log('Server is running on port 1234');
    });
  })
  .catch(error => console.log(error));
```

##### CRUD 操作

通过 `AppDataSource.initialize()` 来初始化数据库连接，在 `then` 内实现 CRUD 路由。

```ts
import { User } from "./entity/User";

AppDataSource.initialize()
  .then(() => {
    const userRepository = AppDataSource.getRepository(User);

    // 创建用户
    app.post("/users", async (req: Request, res: Response, next) => {
      try {
        const { name, email } = req.body;

        console.log(name);

        const user = new User();
        user.name = name;
        user.email = email;

        await userRepository.save(user);
        res.json(user);
      } catch (err) {
        next(err);
      }
    });

    // 获取所有用户
    app.get("/users", async (req, res) => {
      const users = await userRepository.find();
      res.json(users);
    });

    // 根据ID获取单个用户
    app.get("/users/:id", async (req, res) => {
      const user = await userRepository.findOne({
        where: { id: JSON.parse(req.params.id) },
      });
      if (user) {
        res.json(user);
      } else {
        res.status(404).json({ message: "User not found" });
      }
    });

    // 更新用户
    app.put("/users/:id", async (req, res) => {
      const user = await userRepository.findOne({
        where: { id: JSON.parse(req.params.id) },
      });
      if (user) {
        userRepository.merge(user, req.body);
        const result = await userRepository.save(user);
        res.json(result);
      } else {
        res.status(404).json({ message: "User not found" });
      }
    });

    // 删除用户
    app.delete("/users/:id", async (req, res) => {
      const result = await userRepository.delete(req.params.id);
      res.json(result);
    });

    // 启动服务器
    app.listen(1234, () => {
      console.log("Server is running on port 1234");
    });
  })
  .catch((error) => console.log(error));
```

#### Sequelize

> 版本: 6.37.3

使用 Sequelize 作为 ORM（对象关系映射）来结合 Express.js 和 SQLite，能够方便地与数据库交互并简化复杂的 SQL 操作。Sequelize 是一个支持多种数据库的 ORM 工具，能通过模型与数据库表进行映射，并提供了丰富的 API 来实现各种数据库操作。

##### 安装依赖

```bash
npm install express sequelize sqlite3
npm install typescript ts-node @types/node @types/express --save-dev
```

- `express`: Web 框架
- `sequelize`: ORM 工具
- `sqlite3`: SQLite 数据库驱动
- `typescript` 和 `ts-node`: TypeScript 编译工具

##### Sequelize 配置

在项目 src 目录下创建一个 `database.ts` 文件，用于初始化 Sequelize 并连接 SQLite 数据库。

```ts
// database.ts
import { Sequelize } from 'sequelize';

// 初始化 Sequelize 实例，连接 SQLite 数据库
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'database.sqlite', // SQLite 数据库文件的路径
});

export default sequelize;
```

##### 创建模型

在 `src/models` 目录下创建一个 User.ts 文件，定义用户模型。Sequelize 模型类似于数据库中的表，允许我们通过 JavaScript 进行增删改查操作

```ts
// User.ts
import { DataTypes, Model } from 'sequelize';
import sequelize from '../database';

// 定义 User 模型
class User extends Model {
  public id!: number;
  public name!: string;
  public email!: string;
}

User.init(
  {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true,
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    sequelize,
    modelName: 'User',
    tableName: 'users',
    timestamps: false, // 如果不需要 Sequelize 自动生成 createdAt 和 updatedAt
  },
);

export default User;
```

##### 初始化 Sequelize

在 `src/app.ts` 文件中初始化 Sequelize 并创建基本的路由以执行 CRUD 操作。

```ts
// app.ts
import express, { Request, Response } from 'express';
import sequelize from './database';
import User from './models/User';

const app = express();
app.use(express.json());

// 连接数据库并同步模型
sequelize.sync().then(() => {
  console.log('Database synced successfully');
});

// 获取所有用户
app.get('/users', async (req: Request, res: Response) => {
  const users = await User.findAll();
  res.json(users);
});

// 创建新用户
app.post('/users', async (req: Request, res: Response) => {
  const { name, email } = req.body;
  const user = await User.create({ name, email });
  res.json(user);
});

// 根据ID获取单个用户
app.get('/users/:id', async (req: Request, res: Response) => {
  const user = await User.findByPk(req.params.id);
  if (user) {
    res.json(user);
  } else {
    res.status(404).json({ message: 'User not found' });
  }
});

// 更新用户
app.put('/users/:id', async (req: Request, res: Response) => {
  const user = await User.findByPk(req.params.id);
  if (user) {
    user.name = req.body.name;
    user.email = req.body.email;
    await user.save();
    res.json(user);
  } else {
    res.status(404).json({ message: 'User not found' });
  }
});

// 删除用户
app.delete('/users/:id', async (req: Request, res: Response) => {
  const result = await User.destroy({ where: { id: req.params.id } });
  res.json(result);
});

// 启动服务器
app.listen(1234, () => {
  console.log('Server is running on port 1234');
});
```



## 身份验证与安全性

在 Express.js 应用程序中，身份验证与会话管理是确保用户数据安全和访问控制的核心功能。以下是三种常见的身份验证机制：**Cookie** 与 **Session**、**JWT** (JSON Web Token) 以及**路由保护**的详细介绍。

### Cookie 和 Session

Session 通过在服务器端保存会话数据，并在客户端通过 Cookie 存储 Session ID 来实现。客户端的每个请求都会包含这个 ID，服务器根据此 ID 查找并验证会话数据。

#### 安装依赖

```bash
npm install express-session cookie-parser
```

- `express-session`：用于管理服务器端的会话。
- `cookie-parser`：用于解析请求中的 Cookie。

#### 基本实现

以下是一个使用 Session 实现用户会话管理的例子：

```ts
import express from 'express';
import session from 'express-session';
import cookieParser from 'cookie-parser';

const app = express();

// 使用 cookie-parser 解析请求中的 Cookie
app.use(cookieParser());

// 使用 express-session 管理 Session
app.use(
  session({
    secret: 'your-secret-key', // 用于加密 Session ID 的密钥
    resave: false, // 如果 Session 没有修改，是否强制保存
    saveUninitialized: true, // 是否保存未初始化的会话
    cookie: { secure: false }, // 如果使用 HTTPS，secure 应设为 true
  }),
);

// 测试会话存储
app.get('/', (req, res) => {
  if (req.session.views) {
    req.session.views++; // 增加访问次数
    res.send(`You have visited this page ${req.session.views} times`);
  } else {
    req.session.views = 1; // 初始化访问次数
    res.send(
      'Welcome to the session demo! Refresh to see the view count increase.',
    );
  }
});

app.listen(1234, () => {
  console.log('Server is running on http://localhost:1234');
});
```

#### Cookie 和 Session 机制

1. 用户首次访问时，服务器生成一个唯一的 Session ID 并存储在 Cookie 中。
2. 后续的每次请求都会带上这个 Cookie，服务器根据 Session ID 找到对应的会话数据。

#### 登入和登出

```js
// 用户登录
app.post('/login', (req, res) => {
  const { username } = req.body;
  req.session.username = username; // 将用户信息存储在 Session 中
  res.send(`Logged in as ${username}`);
});

// 用户登出
app.post('/logout', (req, res) => {
  req.session.destroy(err => {
    if (err) {
      return res.status(500).send('Logout failed');
    }
    res.send('Logged out successfully');
  });
});
```

### 使用 JWT 进行身份验证

JWT (JSON Web Token) 是一种无状态的身份验证方式，用户信息直接存储在 Token 中，客户端持有 Token，服务器通过验证 Token 来识别用户。

#### 安装依赖

```bash
npm install jsonwebtoken bcryptjs
```

- `jsonwebtoken`：生成和验证 JWT。
- `bcryptjs`：用于加密和验证用户密码。

#### JWT 身份验证流程

1. 用户注册：用户输入用户名和密码，密码通过 bcrypt 加密后存储。
2. 用户登录：用户提供用户名和密码，服务器验证后生成 JWT 并返回给客户端。
3. 验证请求：每次客户端请求时，携带 JWT，服务器验证该 Token 并允许访问受保护资源。

#### 实现用户注册和登录

```ts
import express from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const app = express();
app.use(express.json());

const users: { id: number; username: string; password: string }[] = [];
const secretKey = 'your-secret-key';  // JWT 密钥

// 用户注册
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  const hashedPassword = await bcrypt.hash(password, 10);  // 密码加密
  const newUser = { id: users.length + 1, username, password: hashedPassword };
  users.push(newUser);
  res.status(201).json({ message: 'User registered successfully' });
});

// 用户登录并生成 JWT
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);

  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ message: 'Invalid credentials' });
  }

  // 生成 JWT
  const token = jwt.sign({ id: user.id, username: user.username }, secretKey, { expiresIn: '1h' });
  res.json({ token });
});
```

#### 验证 JWT 的中间件

通过中间件来验证用户请求中的 JWT。

```ts
function authenticateToken(req: any, res: any, next: any) {
  const token = req.headers['authorization'];
  if (!token) return res.sendStatus(401);  // 未提供 Token

  jwt.verify(token.split(' ')[1], secretKey, (err: any, user: any) => {
    if (err) return res.sendStatus(403);  // Token 无效或过期
    req.user = user;  // 将解码的用户信息存储到 req 中
    next();
  });
}
```

#### 受保护的路由

只有已登录并携带有效 JWT 的用户才能访问受保护的路由。

```ts
app.get('/protected', authenticateToken, (req, res) => {
  res.json({ message: 'This is a protected route', user: req.user });
});
```

### 路由保护

通过使用中间件，可以保护特定路由，使得只有通过身份验证的用户才能访问。

在上述 JWT 示例中，`authenticateToken` 函数就是一个用来保护路由的中间件。所有受保护的路由都需要经过这个中间件的验证。

```ts
app.get('/user/profile', authenticateToken, (req, res) => {
  // 用户信息只有在验证通过后才能访问
  res.json({ profile: req.user });
});
```

### 安全性

在使用 Express.js 开发 web 应用时，安全性是非常重要的一个方面。常见的安全攻击包括跨站脚本攻击（XSS）、跨站请求伪造（CSRF）和 SQL 注入。为了防御这些攻击，我们可以采取多种措施，如数据过滤、验证、使用第三方安全库等。

以下是防御这些常见安全攻击的详细说明，以及如何使用 helmet 来增强 Express 应用的安全性。

#### 防御 XSS（跨站脚本攻击）

##### 什么是 XSS？

XSS 攻击是指攻击者通过向网页注入恶意脚本，使用户在访问页面时执行这些脚本。它通常通过不安全的数据输入或输出来实现。

##### 如何防御 XSS？

- 输入过滤与输出编码：永远不要信任用户输入，在处理用户输入的数据时应进行过滤和清理。输出到 HTML 时，应对数据进行编码。
- 使用库来防止 XSS：例如 `xss-clean`、`DOMPurify` 等库可以帮助你过滤不安全的 HTML 内容。

安装 `xss-clean` 库：

```bash
npm install xss-clean
```

在 Express 中应用 `xss-clean`：

```ts
import express from 'express';
import xssClean from 'xss-clean';

const app = express();

// 防御 XSS 攻击
app.use(xssClean());

app.post('/submit', (req, res) => {
  // 假设用户提交的数据被存储或呈现给其他用户
  res.send(`Received input: ${req.body.input}`);
});

app.listen(1234, () => {
  console.log('Server is running on http://localhost:1234');
});
```

#### 防御 CSRF（跨站请求伪造）

##### 什么是 CSRF？

CSRF 攻击是指攻击者通过欺骗用户的身份认证信息，让用户在不知情的情况下执行恶意操作，如发起转账请求、修改密码等。

##### 如何防御 CSRF？

**使用 CSRF 令牌**：每个请求附带一个唯一的 CSRF 令牌，只有服务器生成并验证的令牌才能通过验证。

##### 手动生成和验证 CSRF Token

你可以在每个请求中生成并验证 CSRF Token，通过如下步骤：

- 服务器在用户首次请求页面时生成一个随机的 CSRF Token，并将其存储在用户的 session 或 cookie 中，同时将该 Token 发送到前端（通常通过隐藏表单字段或自定义 HTTP 头）。
- 用户提交表单时，Token 会随着请求发送到服务器。
- 服务器验证请求中的 Token 和 session/cookie 中的 Token 是否匹配。

```js
// 示例
import express from 'express';
const app = express();

const crypto = require('crypto');

// 使用 cookie-parser 中间件
const cookieParser = require('cookie-parser');
app.use(cookieParser());
// 解析body数据
app.use(express.json());

// 生成 CSRF Token
function generateCsrfToken() {
  return crypto.randomBytes(16).toString('hex');
}

// Middleware: 生成 CSRF Token 并添加到 cookie 中
app.use((req, res, next) => {
  if (!req.cookies.csrfToken) {
    const csrfToken = generateCsrfToken();
    res.cookie('csrfToken', csrfToken, { httpOnly: true });
  }
  next();
});

// Middleware: 验证 CSRF Token
function csrfProtection(req, res, next) {
  const tokenFromRequest = req.body.csrfToken || req.headers['x-csrf-token'];
  const tokenFromCookie = req.cookies.csrfToken;

  if (!tokenFromRequest || tokenFromRequest !== tokenFromCookie) {
    return res.status(403).send('Invalid CSRF token');
  }
  next();
}

app.get('/', (req, res) => {
  res.send('Hello World!');
});

// 使用保护中间件
app.post('/submit', csrfProtection, (req, res) => {
  res.send('Form submitted successfully');
});

app.listen(1234, () => {
  console.log('Server is running on http://localhost:1234');
});
```

#### 防御 SQL 注入

##### 什么是 SQL 注入？

SQL 注入攻击是指攻击者通过输入恶意 SQL 代码，从而操纵 SQL 查询，获取或修改数据库中的敏感数据。

##### 如何防御 SQL 注入？

- 使用参数化查询：永远不要直接在 SQL 查询中拼接用户输入，应该使用参数化查询或 ORM 工具来避免 SQL 注入。
- 使用 ORM：如 Sequelize 或 TypeORM，这些工具会自动处理参数化查询，降低 SQL 注入风险。

#### 使用 helmet 增强安全性

`helmet` 是一个非常流行的中间件，它通过设置各种 HTTP 头来帮助防止常见的安全漏洞。它可以自动防止一些常见的攻击，如点击劫持、XSS 和内容注入等。

安装 `helmet`:

```bash
npm install helmet
```

在 Express 中应用 `helmet`：

```ts
import express from 'express';
import helmet from 'helmet';

const app = express();

// 使用 helmet 增强应用安全性
app.use(helmet());

app.get('/', (req, res) => {
  res.send('Helmet is securing your app!');
});

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

helmet 中的部分功能：

- `helmet.hidePoweredBy()`：隐藏 X-Powered-By 头信息，防止暴露服务器框架类型（默认开启）。
- `helmet.xssFilter()`：启用浏览器的 XSS 过滤器。
- `helmet.frameguard()`：防止点击劫持攻击（Clickjacking），默认设置为 deny。
- `helmet.hsts()`：强制使用 HTTPS，保护用户免受 SSL 剥离攻击。

```ts
// 示例
app.use(helmet.xssFilter());
```

你可以通过传入配置对象来自定义 helmet 的某些功能：

```ts
app.use(
  helmet({
    contentSecurityPolicy: false, // 禁用内容安全策略
    frameguard: { action: 'sameorigin' }, // 允许同源的页面在 iframe 中展示
  }),
);
```

